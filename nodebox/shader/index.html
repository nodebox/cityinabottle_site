<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Language" content="en-us" />
		<title>Shader | NodeBox for OpenGL | City in a Bottle</title>
		<meta http-equiv="imagetoolbar" content="no" />
		<meta name="MSSmartTagsPreventParsing" content="true" />
		<meta name="Copyright" content="This site's design and contents Copyright (c) 2007 City In A Bottle." />
		<meta name="keywords" content="City in a Bottle, Creatures, Game, Python, NodeBox, evolution, open-source, blog" />
		<link href="/media/css/screen.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/print.css" rel="stylesheet" type="text/css" media="print" />
		<link rel="alternate" type="application/rss+xml" title="City in a Bottle Blog" href="/rss/blog/" />
		<script type="text/javascript" src="/media/js/swfobject.js"></script>
		
<script type="text/javascript" src="/media/syntax/shCore.js"></script>
<script type="text/javascript" src="/media/syntax/shBrushPython.js"></script>
<link type="text/css" rel="stylesheet" href="/media/syntax/shCore.css"/>
<link type="text/css" rel="stylesheet" href="/media/syntax/shThemeDefault.css"/>
<script type="text/javascript">
	SyntaxHighlighter.config.bloggerMode = true; 
	SyntaxHighlighter.defaults.gutter = false;
	SyntaxHighlighter.defaults.toolbar = false;
	SyntaxHighlighter.all({"brush":"python"});
</script>

	</head>
<body id="documentation">
	<div id="shadow">
	<div id="wrap">
		<div id="nav">
			<a id="nav-homepage" class="first" href="/">Home</a>
			<a id="nav-about" href="/about/">About</a>
			<a id="nav-gallery" href="/gallery/">Gallery</a>
			<a id="nav-download" href="/downloads/">Download</a>
			<a id="nav-contact" href="/contact/">Contact</a>
		</div>
		<div id="masthead">
			
			<a href="/"><img src="/media/img/masthead-small3.jpg"></a>
			
		</div>
		<div id="columnwrap">
			<div id="sectionhead">
			

			</div>
			
		<div id="content">
		
<h2>NodeBox for OpenGL &raquo; Shader <br /></h2><p><a href="/nodebox/">NodeBox</a> module <span class="inline_code">nodebox.graphics.shader</span>  offers functionality to create custom, hardware-accelerated image filters. This functionality might not be supported on older graphics hardware. In that case, <span class="inline_code">nodebox.graphics.shader.SUPPORTED</span> will be <span class="inline_code">False</span>.</p><p>&nbsp;</p><hr size="2" width="100%" /><h2>Shader</h2><p>An OpenGL shader is a pixel effect (e.g. blur, fog, glow) executed on the GPU (Graphics Processing Unit). It is therefore very fast. Shaders are written in <a href="https://en.wikipedia.org/wiki/GLSL" target="_self">GLSL</a>, a variant of the C programming language.</p><p>The <span class="inline_code">Shader</span> object is a Python wrapper for GLSL source code, which you have to write yourself. It compiles the source code, installs the pixel effect and provides an easy mechanism to set variables in the source code from within Python. It expects two distinct parts of GLSL code: the <i>vertex shader</i> and the <i>fragment shader</i>.</p><ul><li><b>GLSL vertex shader</b>: determines the coordinates of the current pixel to process.</li><li><b>GLSL fragment shader</b>: manipulates the color of the current pixel. </li></ul><pre class="brush: python">shader = Shader(vertex=DEFAULT, fragment=DEFAULT)</pre><pre class="brush: python">shader.source                              # Tuple of (vertex, shader)-source.<br />shader.variables                           # Dictionary of (name, value)-items.<br />shader.active                              # True =&gt; shader is being applied.</pre><pre class="brush: python">shader.get(name)                           # Returns the variable's value.<br />shader.set(name, value)                    # Sets the variable's value.<br />shader.push()<br />shader.pop()</pre><ul><li><span class="inline_code"></span><span class="inline_code"></span><span class="inline_code">Shader.get()</span> sets the value of the variable with the given name in the GLSL source code.<br />Supported values: <span class="inline_code">vec2()</span>, <span class="inline_code">vec3()</span>, <span class="inline_code">vec4()</span>, <span class="inline_code">int</span>, <span class="inline_code">float</span>, or a list of <span class="inline_code">int</span> or <span class="inline_code">float</span>.<span class="inline_code"></span></li><li><span class="inline_code">Shader.push()</span> activates the pixel effect with the current variables.<br />When <span class="inline_code">image()</span> is called between <span class="inline_code">Shader.push()</span> and <span class="inline_code">Shader.pop()</span>, the image will be drawn with the effect applied to it.</li><li><span class="inline_code">Shader.pop()</span> deactivates the pixel effect.</li><li><span class="inline_code">ShaderError</span> will be raised if the GLSL source code fails to compile.</li></ul><p>For example, below is a basic effect that colorizes the pixels in an image. It only uses a fragment shader (e.g. how the color of each pixel is modified) &ndash; the default vertex shader is sufficient for most effects. Note how the source code defines three variables: <span class="inline_code">src</span>, <span class="inline_code">color</span>, <span class="inline_code">bias</span>. The <span class="inline_code">src</span> does not need to be set explicitly, it will contain whatever image is currently being drawn. </p><span class="example"><pre class="brush: python">from nodebox.graphics.shader import Shader, vec4<br /><br />colorizer = Shader(fragment='''<br />uniform sampler2D src;<br />uniform vec4 color;<br />uniform vec4 bias;<br />void main() {<br />    vec4 p = texture2D(src, gl_TexCoord[0].xy);<br />    gl_FragColor = clamp(p * color + bias, 0.0, 1.0);<br />}''')</pre></span><p>To make the shader work, values for <span class="inline_code">color</span> and <span class="inline_code">bias</span> need to be set. This is in fact very useful since it allows the shader to be manipulated from the outside, have different visual effects based on different values.</p><span class="example"><pre class="brush: python">colorizer.set(&quot;color&quot;, vec4(1, 0.5, 0.5, 1))<br />colorizer.set(&quot;bias&quot;, vec4(0, 0, 0, 0))<br />colorizer.push()<br />image(&quot;creature.png&quot;, 0, 0)<br />colorizer.pop()<br /></pre></span> <h3>GLSL introduction </h3><p>Below is a short list of essential GLSL syntax. The <span class="inline_code">DEFAULT_VERTEX_SHADER</span> and <span class="inline_code">DEFAULT_FRAGMENT_SHADER</span> offer a glance of how these statements interrelate. Full documentation for the OpenGL Shading Language can be obtained from: <a href="https://www.opengl.org/documentation/glsl/" target="_self">http://www.opengl.org/documentation/glsl/ </a></p><table><tbody><tr><td class="smallcaps">GLSL</td><td><span class="smallcaps">Description </span><br /></td></tr><tr><td class="inline_code">vec4()</td><td>A vector of 4 <span class="inline_code">float</span> numbers. <br />Numbers can be accessed as <span class="inline_code">v.x</span>, <span class="inline_code">v.y</span>, <span class="inline_code">v.z</span>, <span class="inline_code">v.w</span>, or as <span class="inline_code">v.r</span>, <span class="inline_code">v.g</span>, <span class="inline_code">v.b</span>, <span class="inline_code">v.a</span>. <br /></td></tr><tr><td><span class="inline_code">texture2D()</span><br /></td><td>Takes a <span class="inline_code">sampler2D</span> and a <span class="inline_code">vec2</span> of coordinates and returns a <span class="inline_code">vec4</span> with pixel color, <br />i.e. it takes an image and a relative position and returns R,G,B,A for that pixel. <br /></td></tr><tr><td><span class="inline_code">gl_TexCoord[0].xy </span><br /></td><td>The (x,y)-coordinates of the current pixel as a <span class="inline_code">vec2</span>, with values between 0.0-1.0. <br /></td></tr><tr><td class="inline_code">gl_FragColor</td><td>Output of the fragment shader containing the final color for this pixel.</td></tr><tr><td><span class="inline_code">gl_Position </span><br /></td><td>Output of the vertex shader containing the relative coordinates of the current pixel. <br /></td></tr><tr><td><span class="inline_code">uniform </span><br /></td><td>Denotes a variable that can be set from the outside. <br />This is done internally in <span class="inline_code">Shader.push()</span> by calling <span class="inline_code">glUniform()</span>. <br /></td></tr></tbody></table><p>If no value is passed to the <span class="inline_code">vertex</span> or <span class="inline_code">fragment</span> parameter of <span class="inline_code">Shader</span>, a default script is used:&nbsp; </p><pre class="brush: python">DEFAULT_VERTEX_SHADER = '''<br />void main() { <br />&nbsp;&nbsp;&nbsp; gl_TexCoord[0] = gl_MultiTexCoord0; <br />&nbsp;&nbsp;&nbsp; gl_Position = ftransform(); <br />}'''</pre><pre class="brush: python">DEFAULT_FRAGMENT_SHADER = '''<br />uniform sampler2D src;<br />void main() {<br />&nbsp;&nbsp;&nbsp; gl_FragColor = texture2D(src, gl_TexCoord[0].xy);<br />}''' <br /></pre><p>A <span class="inline_code">Shader</span> initialized with these values will have no effect: the fragment shader simply retrieves the color for each pixel and passes it on without modification. </p><p><u>Note</u>: if you plan to mix the pixels of two images (i.e. image compositing), take a look at <span class="inline_code">glsl_compositing</span> and the <span class="inline_code">Compositing</span> filter in the shader.py module. This filter can be subclassed (see the <span class="inline_code">AlphaMask</span> filter for example) and might save you a lot of work.</p><p><span class="small_text"><u>References</u>: <a href="http://www.lighthouse3d.com/opengl/glsl/index.php?fragmentp" target="_self">lighthouse3d.com </a></span></p><p>&nbsp;</p><hr size="2" width="100%" /><h2>Filter</h2><p>The <span class="inline_code">Filter</span> object is a high-level wrapper for <span class="inline_code">Shader</span> with the responsibility to correctly initialize the necessary variables. It can be passed to the optional <span class="inline_code">filter</span> parameter of the <span class="inline_code">image()</span> command. Because GLSL is not as forgiving as Python, setting the variables can be tricky (and tiresome). If you plan to release a custom pixel effect, consider subclassing <span class="inline_code">Filter</span> instead of just writing the <span class="inline_code">Shader</span>. Users will appreciate it.</p><pre class="brush: python">filter = Filter()</pre><pre class="brush: python">filter.shader                              # Shader used.<br />filter.texture                             # Texture to apply the shader to.</pre><pre class="brush: python">filter.push()                              # Set variables and call Shader.push().<br />filter.pop()</pre><p>For example, here is a wrapper for the above <span class="inline_code">colorizer</span> shader that is more user-friendly (it can be passed to <span class="inline_code">image()</span> and works with <span class="inline_code">Color</span> objects so users don't need to know about <span class="inline_code">vec4</span>). </p><span class="example"><pre>class Colorize(Filter):<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def __init__(self, texture, color=Color(1,1,1,1), bias=Color(0,0,0,0)):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.shader&nbsp; = colorizer           # Create a Shader once and reuse it.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.texture = texture<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.color&nbsp;&nbsp; = color<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.bias&nbsp;&nbsp;&nbsp; = bias<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def push(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.shader.set(&quot;color&quot;, vec4(*self.color))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.shader.set(&quot;bias&quot;, vec4(*self.bias))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.shader.push()<br /><br />image(&quot;creature.png&quot;, filter=Colorize(color=(1, 0.5, 0.5, 1)))</pre></span><p>You may wonder why <span class="inline_code">Filter</span> has a <span class="inline_code">texture</span> property if it is not passed to the shader. Indeed, the shader will simply use whatever image is currently drawn, but we may need to know what image that is to set the variables correctly (e.g. a blur effect needs to know about the image size, and there is no way to retrieve the size inside GLSL if we don't pass the information as a variable ourselves).</p><h3>Filter helper functions<br /></h3><p>The module has a number of helper commands that are useful when defining variables in a <span class="inline_code">Filter</span>. </p><p>The <span class="inline_code">vec2()</span>, <span class="inline_code">vec3()</span> and <span class="inline_code">vec4()</span> commands take <span class="inline_code">float</span> numbers and can be passed to <span class="inline_code">Shader.set()</span> to emulate the GLSL <span class="inline_code">vec2</span>, <span class="inline_code">vec3</span> and <span class="inline_code">vec4</span> data types. </p><pre class="brush: python">vec2(f1, f2) </pre><pre class="brush: python">vec3(f1, f2, f3)</pre><pre class="brush: python">vec4(f1, f2, f3, f4)</pre><pre class="brush: python">ceil2(x)</pre><pre class="brush: python">extent2(texture)</pre><pre class="brush: python">ratio2(texture1, texture2) </pre><p>The <span class="inline_code">ceil2()</span> command returns the nearest power of 2 that is higher than <span class="inline_code">x</span>, e.g. 700 =&gt; 1024.</p><p>The <span class="inline_code">extent2()</span> command returns the extent of the image data (0.0-1.0, 0.0-1.0) inside its texture owner. Textures have a size power of 2 (512, 1024, ...), but the actual image can be smaller. For example: a 400 x 250 image will be loaded in a 512 x 256 texture. Its extent is (0.78, 0.98), the remainder of the texture is transparent.&nbsp;</p><p>The <span class="inline_code">ratio2()</span> command returns the size ratio (0.0-1.0, 0.0-1.0) of two texture owners. </p><p>&nbsp;</p><hr size="2" width="100%" /><h2>OffscreenBuffer</h2><p>The <span class="inline_code">OffscreenBuffer</span> object can be used to draw into a hidden texture instead of directly to the canvas. It relies on the OpenGL FBO (Frame Buffer Object) which may not be available on older graphics hardware. In that case, an <span class="inline_code">OffscreenBufferError</span> will be raised. </p><pre class="brush: python">buffer = OffscreenBuffer(width, height)</pre><pre class="brush: python">buffer.texture<br />buffer.active <br /></pre><pre class="brush: python">buffer.push()<br />buffer.pop()<br />buffer.clear()<br />buffer.reset(width=None, height=None)</pre><ul><li><span class="inline_code">OffscreenBuffer.push()</span> activates the buffer.<br />Between <span class="inline_code">OffscreenBuffer.push()</span> and <span class="inline_code">OffscreenBuffer.pop()</span>, all drawing is done offscreen into <span class="inline_code">OffscreenBuffer.texture</span>. The buffer has its own transformation state, so any <span class="inline_code">translate()</span>, <span class="inline_code">rotate()</span> etc. does not affect the onscreen canvas.</li><li><span class="inline_code">OffscreenBuffer.clear()</span> clears the current contents in the buffer.</li><li><span class="inline_code">OffscreenBuffer.reset()</span> creates a new texture of the given size in which to draw. </li></ul><p>Instead of <i>drawing</i> an image with a filter, we may want to <i>apply</i> one or more filters to an image and return it as a new image. A buffer is useful to chain multiple filters together. This is what happens behind the scenes in the <span class="inline_code">render()</span> and <span class="inline_code">filter()</span> commands. </p><p>For example, here is a function that uses the above <span class="inline_code">Colorize</span> class to create a function that returns a new colorized image: </p><span class="example"><pre class="brush: python">def colorize(img, color=(1,1,1,1), bias=(0,0,0,0)):<br />&nbsp;&nbsp;&nbsp; buffer = OffscreenBuffer(img.texture.width, img.texture.height)<br />    buffer.push()<br />    image(img, filter=Colorize(color, bias))<br />    buffer.pop()<br />    return img.copy(texture=buffer.texture)<br /><br />img = colorize(Image(&quot;creature.png&quot;), color=(1, 0.5, 0.5, 1))</pre></span><p>Buffers with a transparent background into which transparent images are blended behave poorly. The functionality in the example above is already bundled in the <span class="inline_code">filter()</span> command, together with specific calls to <span class="inline_code">glBlendFuncSeparate()</span> to produce better transparency effects. You are therefore advised to use <span class="inline_code">filter()</span> instead of the above example:</p><span class="example"><pre class="brush: python">def colorize(img, color=(1,1,1,1), bias=(0,0,0,0)):<br />    return filter(img, Colorize(color, bias))<br /><br />img = colorize(Image(&quot;creature.png&quot;), color=(1, 0.5, 0.5, 1))</pre></span><p><span class="small_text"><u><br />References</u>: <a href="https://www.gamedev.net/reference/articles/article2331.asp" target="_self">gamedev.net</a> (2006), <a href="http://www.openframeworks.cc/forum/viewtopic.php?f=9&amp;t=2215" target="_self">openframeworks.cc</a> (2009) </span></p> 

		</div>
		<div id="sidebar">
		
			<div id="search">
				<form method="get" action="/search/">
					<input type="text" name="q" value="">
					<input type="submit" value="Search" >
				</form>
			</div>
		
		</div>

			<br clear="both">
		</div>
		<div id="footer">
			Copyright &copy; 2007 City in a Bottle. All rights reserved. With support from the Flemish Audiovisual Fund.
		</div>
	</div>
	</div>
	<img src="/media/img/shadow-bottom.png">

<script type="text/javascript">
	//var so = new SWFObject("/media/swf/banner-small.swf","movie", "900","100", "6" ,"#000000")
	//so.write("masthead")
</script>

<script src="https://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
	_uacct = "UA-2297873-2";
	urchinTracker();
</script>
</body>
</html>
