<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Language" content="en-us" />
		<title>Physics | NodeBox for OpenGL | City in a Bottle</title>
		<meta http-equiv="imagetoolbar" content="no" />
		<meta name="MSSmartTagsPreventParsing" content="true" />
		<meta name="Copyright" content="This site's design and contents Copyright (c) 2007 City In A Bottle." />
		<meta name="keywords" content="City in a Bottle, Creatures, Game, Python, NodeBox, evolution, open-source, blog" />
		<link href="/media/css/screen.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/print.css" rel="stylesheet" type="text/css" media="print" />
		<link rel="alternate" type="application/rss+xml" title="City in a Bottle Blog" href="/rss/blog/" />
		<script type="text/javascript" src="/media/js/swfobject.js"></script>
		
<script type="text/javascript" src="/media/syntax/shCore.js"></script>
<script type="text/javascript" src="/media/syntax/shBrushPython.js"></script>
<link type="text/css" rel="stylesheet" href="/media/syntax/shCore.css"/>
<link type="text/css" rel="stylesheet" href="/media/syntax/shThemeDefault.css"/>
<script type="text/javascript">
	SyntaxHighlighter.config.bloggerMode = true; 
	SyntaxHighlighter.defaults.gutter = false;
	SyntaxHighlighter.defaults.toolbar = false;
	SyntaxHighlighter.all({"brush":"python"});
</script>

	</head>
<body id="documentation">
	<div id="shadow">
	<div id="wrap">
		<div id="nav">
			<a id="nav-homepage" class="first" href="/">Home</a>
			<a id="nav-about" href="/about/">About</a>
			<a id="nav-gallery" href="/gallery/">Gallery</a>
			<a id="nav-download" href="/downloads/">Download</a>
			<a id="nav-contact" href="/contact/">Contact</a>
		</div>
		<div id="masthead">
			
			<a href="/"><img src="/media/img/masthead-small3.jpg"></a>
			
		</div>
		<div id="columnwrap">
			<div id="sectionhead">
			

			</div>
			
		<div id="content">
		
<h2>NodeBox for OpenGL &raquo; Physics <br /></h2><p><a href="/nodebox/">NodeBox</a> module <span class="inline_code">nodebox.graphics.physics</span> offers fairly stable functionality to add 2D dynamic effects to an animation, for example a school of fish that moves around fluidly, or a fountain that sprays particles. </p><p>Because of the mathematics involved, this module can benefit from installing <a href="http://psyco.sourceforge.net/" target="_self">Psyco</a>. <br />A version of Psyco precompiled for Mac OS X is included in NodeBox, you can also compile the source manually for other systems. In the <span class="inline_code">nodebox/ext/psyco/src/</span> folder, execute <span class="inline_code">setup.py</span> from the command line: </p><span class="install"><pre>&gt; cd nodebox/ext/psyco/src<br />&gt; python setup.py</pre></span><p>&nbsp;</p><hr size="2" width="100%" /><h2>Vector </h2><p>A <i>Euclidean vector</i> (sometimes called a geometric or spatial vector, or, as here, simply a vector) is a geometric object that has both a magnitude (or length) and a direction. It is commonly used in computer graphics to define <i>where</i> something is going and <i>how fast</i> it is going. </p><pre class="brush: python">v = Vector(x=0, y=0, z=0, length=None, angle=None) <br /></pre><pre class="brush: python">v.xyz                                      # Tuple of (x,y,z)-values.<br />v.xy                                       # Tuple of (x,y)-values.<br />v.x                                        # Magnitude along x-axis.<br />v.y                                        # Magnitude along y-axis.<br />v.z                                        # Magnitude along z-axis.<br />v.length                                   # Magnitude in 3D, if x,y,z != 0.<br />v.angle                                    # Direction in 2D, if x,y,z != 0.</pre><pre class="brush: python">v.copy()<br />v.distance(vector)                         # Returns distance to vector.<br />v.distance2(vector)                        # Returns distance squared (faster).<br />v.normalize()                              # Sets length to 1.0.<br />v.reverse()                                # Sets x,y,z to -x,-y,-z.<br />v.unit                                     # Returns normalized Vector.<br />v.reversed                                 # Returns reversed (opposite) Vector.<br />v.in2D.normal                              # Returns perpendicular Vector.<br />v.in2D.rotate(degrees)                     # Rotates by degrees.<br />v.in2D.rotated(degrees)                    # Returns rotated Vector.<br />v.in2D.angle_to(vector)                    # Returns angle between 2 vectors.</pre><pre class="brush: python">v.dot(vector)                              # Returns dot product as a float.<br />v.cross(vector)                            # Returns cross product Vector. </pre><pre class="brush: python">v.draw(x, y)                               # Draws the vector at (x,y).</pre><p><u>Note</u>: vector rotation works in 2D, so the z-axis will be ignored. <br />This is because (for example) a vector has multiple perpendicular vectors in 3D instead of one. </p><p><span class="inline_code">Vector</span> objects can be used with math operators, either in-place with <span class="inline_code">+=</span>, <span class="inline_code">-=</span>, <span class="inline_code">*=</span> and <span class="inline_code">/=</span> or to return a new <span class="inline_code">Vector</span> with <span class="inline_code">+</span>, <span class="inline_code">-</span>,<span class="inline_code">*</span> and <span class="inline_code">/</span>. The right operand can be either another <span class="inline_code">Vector</span> or a scalar. For example:</p><span class="example"><pre>from nodebox.graphics.physics import Vector<br /><br />v&nbsp; = Vector(1.0, 2.0, 0.0)<br />v += Vector(2.0, 0.0,0.0)<br />v *= 2<br />print v<br /><br />&gt;&gt;&gt; Vector(6.00, 4.00, 0.00)<br /></pre></span><p>&nbsp;</p><hr size="2" width="100%" /><h2>Flocking</h2><p><i>Boids</i> is an artificial life program, developed by <a href="http://www.red3d.com/cwr/boids/" target="_self">Craig Reynolds</a> in 1986, which simulates the flocking behavior of birds. Boids is an example of emergent behavior; the complexity of Boids arises from the interaction of individual agents adhering to a set of simple rules:</p><ul><li><b>separation</b>: steer to avoid crowding local flockmates,</li><li><b>alignment</b>: steer towards the average heading of local flockmates,</li><li><b>cohesion</b>: steer to move toward the average position of local flockmates,</li><li><b>avoidance</b>: steer to avoid colliding with obstacles,</li><li><b>seeking</b>: steer to move toward a target.</li></ul><p>Unexpected behavior, such as splitting flocks and reuniting after avoiding obstacles, can be considered emergent. The boids framework is often used in computer graphics to provide realistic-looking representations of flocks of birds and other creatures, such as schools of fish or herds of animals. </p><h3>Boid </h3><p>The <span class="inline_code">Boid</span> object represents an agent in a <span class="inline_code">Flock</span>, with an (x,y,z)-position subject to different forces. It has a radius of <span class="inline_code">sight</span> that is used to find local flockmates when calculating cohesion and alignment. It has a radius of personal <span class="inline_code">space</span> that is used when calculating separation.</p><pre class="brush: python">boid = Boid(flock, x=0, y=0, z=0, sight=70, space=30)</pre><pre class="brush: python">boid.flock                                 # Flock this boid belongs to.<br />boid.x                                     # Horizontal position.<br />boid.y                                     # Vertical position.<br />boid.z                                     # Depth.<br />boid.depth                                 # Depth, relative between 0.0-1.0.<br />boid.sight                                 # Radius of sight.<br />boid.space                                 # Radius of personal space.<br />boid.velocity                              # Vector.<br />boid.target                                # Vector to chase.<br />boid.heading                               # Bearing as an angle in 2D.<br />boid.dodge                                 # True =&gt; very close to an obstacle.<br /></pre><pre class="brush: python">boid.copy() <br />boid.near(boid, distance=50)               # True if boid is within distance.<br />boid.seek(vector)                          # Sets given Vector as target.<br />boid.update(                               # Update position with given forces.<br />  separation = 0.2, <br />    cohesion = 0.2, <br />   alignment = 0.6, <br />   avoidance = 0.6, <br />      target = 0.2, <br />       limit = 15.0) <br /></pre><h3>Obstacle</h3><p>The <span class="inline_code">Obstacle</span> object can be used to add locations to the flock that the boids will avoid.<br /><u>Note</u>: sometimes boids will be moving too fast to steer away when they perceive an obstacle, and fly through it. Tweaking the radius of the obstacle and the sight and speed of the boid can remedy this. </p><pre class="brush: python">obstacle = Obstacle(x=0, y=0, z=0, radius=10)</pre><pre class="brush: python">obstacle.x<br />obstacle.y<br />obstacle.z<br />obstacle.radius</pre><pre class="brush: python">obstacle.copy()</pre><h3>Flock </h3><p>The <span class="inline_code">Flock</span> object is a list of <span class="inline_code">Boid</span> objects confined to a box area. </p><pre class="brush: python">flock =&nbsp; Flock(amount, x, y, width, height, depth=100.0, obstacles=[])</pre><pre class="brush: python">flock.boids                                # List of Boid objects.<br />flock.obstacles                            # List of Obstacle objects.<br />flock.x                                    # Area left edge.<br />flock.y                                    # Area bottom edge.<br />flock.width                                # Area width.<br />flock.height                               # Area height.<br />flock.depth                                # Area depth.<br />flock.scattered                            # True if boids are not cooperating.<br />flock.gather                               # Chance of reuniting after scatter.<br /></pre><pre class="brush: python">flock.copy()<br />flock.by_depth()                           # List of boids sorted by depth.<br />flock.seek(vector)                         # Sets target Vector for all boids.<br />flock.sight(distance)                      # Sets sight for all boids.<br />flock.space(distance)                      # Sets space for all boids.<br />flock.scatter(gather=0.05)                 # Scatters the flock.<br />flock.update(                              # Update positions with given forces.<br />  separation = 0.2, <br />    cohesion = 0.2, <br />   alignment = 0.6, <br />   avoidance = 0.6, <br />      target = 0.2, <br />       limit = 15.0, <br />   constrain = 1.0, <br />    teleport = False)<br /></pre><p>The example below demonstrates a school of fish. Different behavior arises from the interplay between all forces, so you'll have to tweak the numbers to get it right. In this example, <span class="inline_code">Flock.update()</span> has <span class="inline_code">teleport</span> set to <span class="inline_code">True</span> so the boids wrap around the edges instead of turning back. Another thing to remember is to set&nbsp; <span class="inline_code">limit</span> high enough, otherwise the boids will be too constrained and start moving in a straight line. </p><span class="example"><pre>from nodebox.graphics import *<br />from nodebox.graphics.physics import Vector, Boid, Flock, Obstacle<br /><br />flock = Flock(50, x=-50, y=-50, width=700, height=400)<br />flock.sight(80)<br /><br />def draw(canvas):<br />&nbsp;&nbsp;&nbsp; canvas.clear()<br />&nbsp;&nbsp;&nbsp; flock.update(separation=0.4, cohesion=0.6, alignment=0.1, teleport=True)<br />&nbsp;&nbsp;&nbsp; for boid in flock:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; translate(boid.x, boid.y)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scale(0.5 + boid.depth)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotate(boid.heading)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrow(0, 0, 15)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop()<br /><br />canvas.size = 600, 300<br />canvas.run(draw)&nbsp;</pre></span><p><img src="/media/img/nodebox-physics-flock.jpg" class="image_border" alt="nodebox-physics-flock" /> </p><p class="small_text"><u>References</u>: <a href="http://www.vergenet.net/~conrad/boids/pseudocode.html" target="_self">vergenet.net/~conrad</a> (2007) </p><p>&nbsp;</p><hr size="2" width="100%" /><h2>Particle system</h2><p>A <i>particle system</i> is a computer graphics technique to simulate certain fuzzy phenomena which are otherwise very hard to reproduce with conventional rendering techniques: fire, explosions, smoke, moving water, sparks, falling leaves, clouds, fog, snow, dust, meteor tails, hair, fur, grass, or abstract visual effects like glowing trails, magic spells. </p><h3>Force</h3><p>A <span class="inline_code">Force</span> causes objects with a mass to accelerate. It acts as a repulsive or attractive dynamic between two particles. A negative <span class="inline_code">strength</span> indicates an attractive force. The closer particles are, the exponentially greater the force will be. The <span class="inline_code">threshold</span> defines a minimum distance to use in calculations &ndash; otherwise the force can grow too large (e.g. particles fall outside the canvas before the effect can be perceived) .</p><pre class="brush: python">force = Force(particle1, particle2, strength=1.0, threshold=100.0)</pre><pre class="brush: python">force.particle1<br />force.particle2<br />force.strength<br />force.threshold</pre><pre class="brush: python">force.apply()</pre><h3>Spring</h3><p>A <span class="inline_code">Spring</span> exerts attractive resistance when its length changes. It acts as a flexible (but secure) connection between two particles. </p><pre class="brush: python">spring = Spring(particle1, particle2, length, strength=1.0)</pre><pre class="brush: python">spring.particle1<br />spring.particle2<br />spring.strength<br />spring.length<br />spring.snapped                             # When True, the spring breaks.</pre><pre class="brush: python">spring.apply()</pre><pre class="brush: python">spring.draw()</pre><h3>Particle</h3><p>A <span class="inline_code">Particle</span> is an object with a mass that can be subjected to attractive and repulsive forces (unless <span class="inline_code">Particle.fixed</span> is set to <span class="inline_code">True</span>). The object's <span class="inline_code">velocity</span> is an inherent force (e.g. a rocket propeller to escape gravity). A particle can have a <span class="inline_code">life</span> span, which is the number of updates before it disappears. Each <span class="inline_code">System.update()</span>, a particle loses 1 life. Dead particles are not updated or drawn. </p><pre class="brush: python">particle = Particle(x, y, velocity=(0.0,0.0), mass=10.0, radius=10.0, life=None, fixed=False)</pre><pre class="brush: python">particle.x                                 # Horizontal position.<br />particle.y                                 # Vertical position.<br />particle.mass                              # Weight (lighter = greater forces).<br />particle.radius                            # Used when drawn (radius != mass).<br />particle.velocity                          # Vector.<br />particle.life                              # None, or a number.<br />particle.age                               # 0.0-1.0, if life is defined.<br />particle.dead                              # True when age=1.0.<br />particle.fixed                             # Influenced by forces?</pre><pre class="brush: python">particle.draw()</pre><p>Particles are drawn as circles whose radius diminishes as they age. The <span class="inline_code">Particle.draw()</span> method can of course be overridden with custom behavior. This is what the default method looks like:</p><span class="example"><pre>class Particle:<br />&nbsp;&nbsp;&nbsp; def draw(self, **kwargs):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; r = self.radius * (1 - self.age)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ellipse(self.x, self.y, r*2, r*2, **kwargs) <br /></pre></span><h3>System </h3><p>A <span class="inline_code">System</span> is a collection of particles, particle emitters, forces and springs:&nbsp; </p><pre class="brush: python">system = System(gravity=(0,0), drag=0.0)</pre><pre class="brush: python">system.particles                           # List of Particle objects.<br />system.emitters                            # List of Emitter objects.<br />system.forces                              # List of Force objects.<br />system.springs                             # List of Spring objects.<br />system.gravity                             # Global attractive force.<br />system.drag                                # Global resisting force.<br />system.dead                                # True if all particles are dead.<br /></pre><pre class="brush: python">system.append()                            # Particle, Emitter, Force, Spring.</pre><pre class="brush: python">system.force(strength=1.0, threshold=100, source=None, particles=[]) <br />system.dynamics(particle, type=None)<br />system.update(limit=30)</pre><pre class="brush: python">system.draw()</pre><ul><li><span class="inline_code">System.force()</span> creates a new <span class="inline_code">Force</span> that is applied between each two particles.<br />The effect this yields (with a repulsive force) is an explosion.<br />When <span class="inline_code">source</span> is a <span class="inline_code">Particle</span>, applies the force to this particle against all others.<br />When <span class="inline_code">particles</span> are given, only apply the force to these <span class="inline_code">Particle</span> objects.<br />The force is applied to particles present in the system, those added later on are not subjected to the force. Be aware that 50 particles wield yield 50 x 50 / 2 = 1250 forces. This has an impact on performance.</li><li><span class="inline_code">System.dynamics()</span> returns a list of forces on the given particle, filtered by type (e.g. <span class="inline_code">type=Spring</span>).</li><li><span class="inline_code">System.update()</span> updates the location of the particles by applying forces and firing emitters.</li></ul><span class="small_text"><u>Note</u>: the current implementation of <span class="inline_code">System</span> is experimental &ndash; it is not always stable. To make it better, a solver (Euler, Runge-Kutta) needs to be added. Right now the whole force is simply added to the particle's position, which has the effect that particles can start &quot;shivering&quot;. This is done for performance.</span> <h3>Emitter </h3><p>The <span class="inline_code">Emitter</span> object can be used as a source that shoots particles in a given direction with a given strength. It can be added to a system with <span class="inline_code">System.append()</span>. </p><pre class="brush: python">emitter = Emitter(x, y, angle=0, strength=1.0, spread=10)</pre><pre class="brush: python">emitter.system                             # System the emitter is part of. <br />emitter.particles                          # Particles fired by the emitter.<br />emitter.x                                  # Horizontal position.<br />emitter.y                                  # Vertical position.<br />emitter.angle                              # Firing direction.<br />emitter.strength                           # Firing force.<br />emitter.spread                             # Less spread = shoots straighter.<br /></pre><pre class="brush: python">emitter.append(particle, life=100) </pre><ul><li> <span class="inline_code">Emitter.append()</span> adds a <span class="inline_code">Particle</span> (i.e. ammo) to the emitter. <br />The optional <span class="inline_code">life</span> parameter sets the default lifespan of the particle &ndash; dead particles can be reused (e.g. they are fired again) &ndash; otherwise the emitter either stops firing or you need to keep adding more and more particles.</li></ul><p>Here is a simple example of a system with an emitter spraying particles:</p><span class="example"><pre>from nodebox.graphics import *<br />from nodebox.graphics.physics import System, Emitter, Particle, MASS<br /><br />e = Emitter(x=300, y=0, angle=90, spread=60, strength=4)<br />for i in range(100):<br />&nbsp;&nbsp;&nbsp; e.append(<br />        Particle(0, 0, <br />            life = random(50,250), <br />            mass = random(10,20), <br />          radius = MASS)<br />system = System(gravity=(0,1), drag=0.005)<br />system.append(e)<br /><br />def draw(canvas):<br />&nbsp;&nbsp;&nbsp; background(1)<br />&nbsp;&nbsp;&nbsp; fill(0, 0.5)<br />&nbsp;&nbsp;&nbsp; stroke(0, 0.5)<br />&nbsp;&nbsp;&nbsp; system.update()&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; system.draw()<br /><br />canvas.size = 600, 300<br />canvas.run(draw)</pre></span><p><img src="/media/img/nodebox-physics-emitter.jpg" class="image_border" alt="nodebox-physics-emitter" /> </p><p class="small_text"><u>References</u>: <a href="http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/particle/" target="_self">local.wasp.uwa.edu.au</a> (1998) </p><p>&nbsp;</p><p>&nbsp;</p><hr size="2" width="100%" /><a name="graph" title="graph"></a><h2>Graph</h2><p>A graph is a data structure consisting of nodes (or vertices) connected by edges. Among other things, graph algorithms are concerned with finding the shortest path between nodes, which could for example represent the road an AI-controlled game character should follow. Or estimating node <i>centrality</i>: which nodes occur more frequently in paths, for example to rank web pages in a network.</p><h3>Node</h3><p>The <span class="inline_code">Node</span> object represents an element in the graph. It has a unique <span class="inline_code">id</span> that is drawn as a text label next to the node, unless the optional <span class="inline_code">text</span> parameter is <span class="inline_code">False</span>. Otherwise, the <span class="inline_code">text</span> parameter defines the label color &ndash; <span class="inline_code">(0,0,0,1)</span> by default. Optional parameters include: <span class="inline_code">fill</span>, <span class="inline_code">stroke</span>, <span class="inline_code">strokewidth</span>, <span class="inline_code">text</span>, <span class="inline_code">font</span>, <span class="inline_code">fontsize</span>, <span class="inline_code">fontweight</span> to style the node.</p><pre>node = Node(id=&quot;&quot;, radius=5, **kwargs)</pre><pre>node.graph                                 # Graph the node is part of.<br />node.edges                                 # List of Edge objects.<br />node.links                                 # List of Node objects.<br />node.id                                    # Unique string or int.</pre><pre>node.x                                     # Horizontal offset.<br />node.y                                     # Vertical offset.<br />node.force                                 # Vector, updated by Graph.layout.<br />node.radius                                # Default: 5<br />node.fill                                  # Default: None<br />node.stroke                                # Default: (0,0,0,1)<br />node.strokewidth                           # Default: 1<br />node.text                                  # Text object, or None.</pre><pre>node.weight                                # Eigenvector centrality (0.0-1.0).<br />node.centrality                            # Betweenness centrality (0.0-1.0).</pre><pre>node.flatten(depth=1)                      # List of linked nodes + self. <br /></pre><pre>node.draw(weighted=False)</pre><pre>node.contains(x, y)                        # True =&gt; (x,y) in radius. <br /></pre><ul><li><span class="inline_code">Node.links.edge(node)</span> yields the <span class="inline_code">Edge</span> connecting this node to the given <span class="inline_code">node</span>.</li><li><span class="inline_code">Node.draw()</span> draws the node as a circle with the defined radius, fill and stroke.<br />With <span class="inline_code">weighted=True</span>, a node with a high centrality is marked with a dropshadow.</li></ul><p class="smallcaps">Node weight and centrality</p><ul><li><span class="inline_code">Node.centrality</span> indicates the node's <i>betweenness</i>: how often it occurs in shortest paths, as a value between <span class="inline_code">0.0-1.0</span>. Highly trafficked nodes can be thought of as hubs, landmarks, city centers and so on.<span class="inline_code"></span></li><li><span class="inline_code">Node.weight</span> indicates the node's <i>eigenvector centrality</i>: how many nodes are connected to it, as a value between <span class="inline_code">0.0-1.0</span>. Nodes that (indirectly) connect to high-scoring nodes get a better score themselves. In this case the edge direction plays an important role. Ideally, everyone is pointing at you and you are pointing at no-one - meaning you are at the top of hierarchy. </li></ul><h3>Edge</h3><p>The <span class="inline_code">Edge</span> object represents a connection between two nodes. Its <span class="inline_code">weight</span> indicates the importance (not the cost) of the connection. Edges with a higher weight are preferred in shortest paths. Optional parameters include <span class="inline_code">stroke</span> and <span class="inline_code">strokewidth</span>.</p><pre>edge = Edge(node1, node2, weight=0.0, length=1.0, type=None, **kwargs) </pre><pre>edge.node1                                 # Node (sender).<br />edge.node2                                 # Node (receiver).<br />edge.weight                                # Connection strength.<br />edge.length                                # Length modifier when drawn.<br />edge.type                                  # None, useful for semantic networks.<br />edge.stroke                                # Default: (0,0,0,1)<br />edge.strokewidth                           # Default: 1 </pre><pre>edge.draw(weighted=False, directed=False)<br />edge.draw_arrow(stroke, strokewidth) </pre><ul><li><span class="inline_code">Edge.draw()</span> draws the edge as a line connecting the two nodes.<br />With <span class="inline_code">weighted=True</span>, a heavier edge will have a thicker strokewidth.<br />With <span class="inline_code">directed=True</span>, <span class="inline_code">Edge.draw()</span> will call <span class="inline_code">Edge.draw_arrow()</span> to indicate the edge direction (this requires extra calculations). </li></ul><h3>Graph</h3><p>The <span class="inline_code">Graph</span> object is a collection of nodes and edges that can be drawn with a given layout. Currently, the only layout available is <span class="inline_code">SPRING</span>, which uses a force-based algorithm in which edges are regarded as springs. The forces are applied to the nodes, pulling them closer together or pushing them further apart.</p><pre>graph = Graph(layout=SPRING, distance=10.0)</pre><pre>graph.nodes                                # List of Node objects.<br />graph.edges                                # List of Edge objects.<br />graph.root                                 # Node or None.<br />graph.density                              # &lt;0.35 =&gt; sparse, &gt;0.65 =&gt; dense<br />graph.distance                             # Overall layout spacing.<br />graph.layout                               # GraphSpringLayout.<br /></pre><pre>graph.add_node(id, *args, **kwargs, root=False)<br />graph.add_edge(id1, id2, *args, **kwargs)<br />graph.remove(node)<br />graph.remove(edge)<br />graph.node(id)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Returns Node with given id.<br />graph.edge(id1, id2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Returns Edge for given node id's. </pre><pre>graph.betweenness_centrality() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Updates Node.centrality.<br />graph.eigenvector_centrality() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Updates Node.weight. <br /></pre><pre>graph.shortest_path(node1, node2, heuristic=None, directed=False)<br />graph.shortest_paths(node, heuristic=None, directed=False)<br />graph.paths(node1, node2, length=4)<br />graph.sorted(order=WEIGHT, threshold=0.0)<br />graph.prune(depth=0)<br />graph.fringe(depth=0)<br />graph.split()<br />graph.copy(nodes=ALL)<br /></pre><pre>graph.update(iterations=10, weight=10, limit=0.5)<br />graph.draw(weighted=False, directed=False) </pre><ul><li><span class="inline_code">Graph.shortest_path()</span> returns a list of nodes connecting two nodes.</li><li><span class="inline_code">Graph.shortest_paths()</span> returns a dictionary of nodes linked to shortest path.<br />With <span class="inline_code">directed=True</span>, edges are only traversable in a single direction.<br />A <span class="inline_code">heuristic</span> function can be given that takes two node id's and returns an additional cost for movement between the two nodes.</li><li><span class="inline_code">Graph.paths()</span> returns a list of paths &lt;= <span class="inline_code">length</span> connecting the two nodes.</li><li><span class="inline_code">Graph.sorted()</span> returns a list of nodes sorted by <span class="inline_code">WEIGHT</span> or <span class="inline_code">CENTRALITY</span>.<br />If the value falls below the given <span class="inline_code">threshold</span>, the node is excluded from the list.</li><li><span class="inline_code">Graph.prune()</span> removes all nodes with less or equal links than <span class="inline_code">depth</span>.</li><li><span class="inline_code">Graph.fringe()</span> returns a list of leaf nodes.<br />With <span class="inline_code">depth=0</span>, returns the nodes with only one connection.<br />With <span class="inline_code">depth=1</span>, returns the nodes with one connection + their connections, etc.</li><li><span class="inline_code">Graph.split()</span> returns a list of unconnected subgraphs.</li><li><span class="inline_code">Graph.copy()</span> returns a new graph from the given list of nodes.</li></ul><h3>Graph layout </h3><p>A <span class="inline_code">GraphLayout</span> object calculates node positions iteratively when <span class="inline_code">GraphLayout.update()</span> is called. Currently, the only available implementation is <span class="inline_code">GraphSpringLayout</span>.</p><pre>layout = GraphSpringLayout(graph)<br /></pre><pre>layout.graph                               # Graph owner.<br />layout.iterations                          # Starts at 0, +1 on each update().<br />layout.bounds                              # (x, y, width, height)-tuple.<br /></pre><pre>layout.k                                   # Force constant   (4.0)<br />layout.force                               # Force multiplier (0.01) <br />layout.repulsion                           # Maximum repulsion radius (15)</pre><pre>layout.update(weight=10.0, limit=0.5)      # weight =&gt; Edge.weight multiplier.<br />layout.reset()<br />layout.copy(graph)<br /></pre><p>Here is a simple example of a graph with random nodes and edges:</p><span class="example"><pre>from nodebox.graphics import *<br />from nodebox.graphics.physics import Node, Edge, Graph<br /><br />g = Graph()<br />for i in range(50):<br />&nbsp;&nbsp;&nbsp; g.add_node(id=i, stroke=Color(0), strokewidth=1)<br />for i in range(50):<br />&nbsp;&nbsp;&nbsp; node1 = choice(g.nodes)<br />&nbsp;&nbsp;&nbsp; node2 = choice(g.nodes)<br />&nbsp;&nbsp;&nbsp; g.add_edge(node1.id, node2.id, weight=random(), stroke=Color(0), strokewidth=1)<br /><br />def draw(canvas):<br />&nbsp;&nbsp;&nbsp; background(1)<br />&nbsp;&nbsp;&nbsp; translate(250, 250)<br />&nbsp;&nbsp;&nbsp; g.draw(weighted=True, directed=True)<br />&nbsp;&nbsp;&nbsp; g.update()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />canvas.size = 500, 500<br />canvas.run(draw)</pre></span><p><img src="/media/img/nodebox-physics-graph.jpg" class="image_border" height="300" width="600" /> </p><p><span class="small_text"><u>References</u>: <a href="http://networkx.lanl.gov/">NetworkX</a> (2008), <a href="http://snipplr.com/view/1950/graph-javascript-framework-version-001/">Hellesoy &amp; Hoover</a> (2006), <a href="https://code.activestate.com/recipes/119466/">Eppstein &amp; Barnes</a> (2005),&nbsp; <a href="http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf">Brandes</a></span>  (2001)</p>

		</div>
		<div id="sidebar">
		
			<div id="search">
				<form method="get" action="/search/">
					<input type="text" name="q" value="">
					<input type="submit" value="Search" >
				</form>
			</div>
		
		</div>

			<br clear="both">
		</div>
		<div id="footer">
			Copyright &copy; 2007 City in a Bottle. All rights reserved. With support from the Flemish Audiovisual Fund.
		</div>
	</div>
	</div>
	<img src="/media/img/shadow-bottom.png">

<script type="text/javascript">
	//var so = new SWFObject("/media/swf/banner-small.swf","movie", "900","100", "6" ,"#000000")
	//so.write("masthead")
</script>

<script src="https://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
	_uacct = "UA-2297873-2";
	urchinTracker();
</script>
</body>
</html>
